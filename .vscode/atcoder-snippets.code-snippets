{
  "convolution_mod": {
    "prefix": "convolution_mod",
    "body": [
      "#[allow(dead_code)]",
      "fn butterfly<",
      "    T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T>,",
      ">(",
      "    f: &mut [T],",
      "    w_pow: &[T],",
      ") {",
      "    let n = f.len();",
      "    assert!(n.is_power_of_two());",
      "    let h = n.trailing_zeros() as usize;",
      "    let w4 = w_pow[n / 4];",
      "    for (i, step) in (0..=h + 1)",
      "        .step_by(2)",
      "        .map(|i| usize::min(i, h))",
      "        .tuple_windows()",
      "        .map(|(i, i2)| (i, i2 - i))",
      "    {",
      "        if step == 1 {",
      "            let b = 1 << i;",
      "            let c = n >> (i + 1);",
      "            let d = n >> i;",
      "            for k in 0..b {",
      "                for j in 0..c {",
      "                    let p = w_pow[j * b];",
      "                    let t0 = f[k * d + j];",
      "                    let t1 = f[k * d + j + c];",
      "                    f[k * d + j] = t0 + t1;",
      "                    f[k * d + j + c] = p * (t0 - t1);",
      "                }",
      "            }",
      "        } else {",
      "            assert!(step == 2);",
      "            let b = 1 << i;",
      "            let c = n >> (i + 2);",
      "            let d = n >> i;",
      "            for k in 0..b {",
      "                for j in 0..c {",
      "                    let p = w_pow[j * b];",
      "                    let p2 = p * p;",
      "                    let p3 = p2 * p;",
      "                    let t0 = f[k * d + j];",
      "                    let t1 = f[k * d + j + c];",
      "                    let t2 = f[k * d + j + 2 * c];",
      "                    let t3 = f[k * d + j + 3 * c];",
      "                    f[k * d + j] = t0 + t1 + t2 + t3;",
      "                    f[k * d + j + c] = p2 * (t0 - t1 + t2 - t3);",
      "                    f[k * d + j + 2 * c] = p * (t0 + w4 * t1 - t2 - w4 * t3);",
      "                    f[k * d + j + 3 * c] = p3 * (t0 - w4 * t1 - t2 + w4 * t3);",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn butterfly_inv<",
      "    T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T>,",
      ">(",
      "    f: &mut [T],",
      "    w_pow: &[T],",
      ") {",
      "    let n = f.len();",
      "    assert!(n.is_power_of_two());",
      "    let h = n.trailing_zeros() as usize;",
      "    let w4 = w_pow[n / 4];",
      "    for (i, step) in (0..=h + 1)",
      "        .step_by(2)",
      "        .map(|i| usize::min(i, h))",
      "        .tuple_windows()",
      "        .map(|(i, i2)| (i, i2 - i))",
      "    {",
      "        if step == 1 {",
      "            let b = 1 << i;",
      "            let c = n >> (i + 1);",
      "            let b2 = b * 2;",
      "            for j in 0..c {",
      "                for k in 0..b {",
      "                    let p = w_pow[k * c];",
      "                    let t1 = f[j * b2 + k];",
      "                    let t2 = p * f[j * b2 + k + b];",
      "                    f[j * b2 + k] = t1 + t2;",
      "                    f[j * b2 + k + b] = t1 - t2;",
      "                }",
      "            }",
      "        } else {",
      "            assert!(step == 2);",
      "            let b = 1 << i;",
      "            let c = n >> (i + 2);",
      "            let b4 = 4 * b;",
      "            for j in 0..c {",
      "                for k in 0..b {",
      "                    let p = w_pow[k * c];",
      "                    let p2 = p * p;",
      "                    let p3 = p2 * p;",
      "                    let t0 = f[j * b4 + k];",
      "                    let t1 = p2 * f[j * b4 + k + b];",
      "                    let t2 = p * f[j * b4 + k + 2 * b];",
      "                    let t3 = p3 * f[j * b4 + k + 3 * b];",
      "                    f[j * b4 + k] = t0 + t1 + t2 + t3;",
      "                    f[j * b4 + k + b] = t0 - t1 + w4 * t2 - w4 * t3;",
      "                    f[j * b4 + k + 2 * b] = t0 + t1 - t2 - t3;",
      "                    f[j * b4 + k + 3 * b] = t0 - t1 - w4 * t2 + w4 * t3;",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn reverse_bits_order<",
      "    T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T>,",
      ">(",
      "    f: &mut [T],",
      ") {",
      "    let n = f.len();",
      "    assert!(n.is_power_of_two());",
      "    let h = n.trailing_zeros() as usize;",
      "    for i in 0..n {",
      "        let j = i.reverse_bits() >> (std::mem::size_of::<usize>() * 8 - h);",
      "        if i < j {",
      "            f.swap(i, j);",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn convolution_impl<",
      "    T: Copy",
      "        + std::ops::Add<Output = T>",
      "        + std::ops::Sub<Output = T>",
      "        + std::ops::Mul<Output = T>",
      "        + std::ops::MulAssign",
      "        + std::ops::DivAssign,",
      ">(",
      "    p: &mut [T],",
      "    q: &mut [T],",
      "    w_pow: &[T],",
      "    iw_pow: &[T],",
      "    n_as_t: T,",
      ") {",
      "    let n = p.len();",
      "    assert!(q.len() == n);",
      "    assert!(n.is_power_of_two());",
      "    butterfly(p, &w_pow);",
      "    butterfly(q, &w_pow);",
      "    for (x, y) in p.iter_mut().zip(q) {",
      "        *x *= *y;",
      "    }",
      "    butterfly_inv(p, &iw_pow);",
      "    p.iter_mut().for_each(|x| *x /= n_as_t);",
      "}",
      "#[allow(dead_code)]",
      "fn primitive_root(m: usize) -> usize {",
      "    match m {",
      "        2 => return 1,",
      "        167772161 => return 3,",
      "        469762049 => return 3,",
      "        754974721 => return 11,",
      "        998244353 => return 3,",
      "        1224736769 => return 3,",
      "        1811939329 => return 13,",
      "        2013265921 => return 31,",
      "        _ => {}",
      "    };",
      "    let primes = (2..)",
      "        .try_fold((vec![], m - 1), |(mut primes, x), i| {",
      "            if i * i > x {",
      "                if x > 1 {",
      "                    primes.push(x);",
      "                }",
      "                Err(primes)",
      "            } else if x % i > 0 {",
      "                Ok((primes, x))",
      "            } else {",
      "                primes.push(i);",
      "                let x = itertools::iterate(x, |x| x / i)",
      "                    .find(|&x| x % i > 0)",
      "                    .unwrap();",
      "                Ok((primes, x))",
      "            }",
      "        })",
      "        .unwrap_err();",
      "    (2..)",
      "        .find(|&g| primes.iter().all(|&p| pow_mod(g, (m - 1) / p, m) != 1))",
      "        .unwrap()",
      "}",
      "#[allow(dead_code)]",
      "pub fn convolution_mod<M: Modulus>(p: &[Mod<M>], q: &[Mod<M>]) -> Vec<Mod<M>> {",
      "    let n0 = p.len();",
      "    let n1 = q.len();",
      "    if std::cmp::min(n0, n1) <= 64 {",
      "        let mut r = vec![Mod::new(0); n0 + n1 - 1];",
      "        for (i, &pp) in p.iter().enumerate() {",
      "            for (j, &qq) in q.iter().enumerate() {",
      "                r[i + j] = r[i + j] + pp * qq;",
      "            }",
      "        }",
      "        return r;",
      "    }",
      "    let n = (n0 + n1 - 1).next_power_of_two();",
      "    let mut pf = p",
      "        .iter()",
      "        .copied()",
      "        .chain(std::iter::repeat(Mod::new(0)))",
      "        .take(n)",
      "        .collect::<Vec<_>>();",
      "    let mut qf = q",
      "        .iter()",
      "        .copied()",
      "        .chain(std::iter::repeat(Mod::new(0)))",
      "        .take(n)",
      "        .collect::<Vec<_>>();",
      "    let g = primitive_root(M::modulus());",
      "    let c = pow_mod(g, (M::modulus() - 1) / n, M::modulus());",
      "    let w_pow = (0..n)",
      "        .scan(Mod::new(1), |p, _| Some(std::mem::replace(p, *p * c)))",
      "        .collect::<Vec<_>>();",
      "    let cinv = pow_mod(g, (M::modulus() - 1) / n * (n - 1), M::modulus());",
      "    let iw_pow = (0..n)",
      "        .scan(Mod::new(1), |p, _| Some(std::mem::replace(p, *p * cinv)))",
      "        .collect::<Vec<_>>();",
      "    convolution_impl(&mut pf, &mut qf, &w_pow, &iw_pow, Mod::new(n));",
      "    pf.resize(n0 + n1 - 1, Mod::new(0));",
      "    pf",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "#[allow(dead_code)]",
      "fn dijkstra(g: &WeightedGraph, src: usize) -> Vec<usize> {",
      "    let n = g.size();",
      "    let mut q = std::collections::BinaryHeap::new();",
      "    let mut costs = vec![std::usize::MAX; n];",
      "    q.push(std::cmp::Reverse((0, src)));",
      "    costs[src] = 0;",
      "    while let Some(std::cmp::Reverse((cost, v))) = q.pop() {",
      "        if cost > costs[v] {",
      "            continue;",
      "        }",
      "        for &edge in &g.out_edges[v] {",
      "            let next_cost = cost + edge.label;",
      "            if next_cost < costs[edge.to] {",
      "                q.push(std::cmp::Reverse((next_cost, edge.to)));",
      "                costs[edge.to] = next_cost;",
      "            }",
      "        }",
      "    }",
      "    costs",
      "}"
    ]
  },
  "dijkstra1": {
    "prefix": "dijkstra1",
    "body": [
      "#[allow(dead_code)]",
      "fn dijkstra1(g: &WeightedGraph, src: usize, dst: usize) -> Option<usize> {",
      "    let n = g.size();",
      "    let mut q = std::collections::BinaryHeap::new();",
      "    let mut costs = vec![std::usize::MAX; n];",
      "    q.push(std::cmp::Reverse((0, src)));",
      "    costs[src] = 0;",
      "    while let Some(std::cmp::Reverse((cost, v))) = q.pop() {",
      "        if cost > costs[v] {",
      "            continue;",
      "        }",
      "        if v == dst {",
      "            return Some(cost);",
      "        }",
      "        for &edge in &g.out_edges[v] {",
      "            let next_cost = cost + edge.label;",
      "            if next_cost < costs[edge.to] {",
      "                q.push(std::cmp::Reverse((next_cost, edge.to)));",
      "                costs[edge.to] = next_cost;",
      "            }",
      "        }",
      "    }",
      "    None",
      "}"
    ]
  },
  "dualsegtree": {
    "prefix": "dualsegtree",
    "body": [
      "fn range(r: impl std::ops::RangeBounds<usize>, n: usize) -> (usize, usize) {",
      "    let start = match r.start_bound() {",
      "        std::ops::Bound::Excluded(&i) => i + 1,",
      "        std::ops::Bound::Included(&i) => i,",
      "        std::ops::Bound::Unbounded => 0,",
      "    };",
      "    let end = match r.end_bound() {",
      "        std::ops::Bound::Excluded(&i) => i,",
      "        std::ops::Bound::Included(&i) => i + 1,",
      "        std::ops::Bound::Unbounded => n,",
      "    };",
      "    (start, end)",
      "}",
      "trait Monoid {",
      "    fn id() -> Self;",
      "    fn op(&self, rhs: &Self) -> Self;",
      "}",
      "#[derive(Debug)]",
      "struct DualSegmentTree<Op>",
      "where",
      "    Op: Monoid,",
      "{",
      "    height: usize,",
      "    cap: usize,",
      "    n: usize,",
      "    lazy: Vec<Op>,",
      "}",
      "#[allow(dead_code)]",
      "impl<Op> DualSegmentTree<Op>",
      "where",
      "    Op: Monoid + Clone,",
      "{",
      "    fn new(n: usize) -> Self {",
      "        let cap = n.next_power_of_two();",
      "        DualSegmentTree {",
      "            height: cap.trailing_zeros() as usize + 1,",
      "            n,",
      "            cap,",
      "            lazy: vec![Op::id(); 2 * cap - 1],",
      "        }",
      "    }",
      "    fn with<T>(vals: &[T]) -> Self",
      "    where",
      "        T: Into<Op> + Clone,",
      "    {",
      "        let n = vals.len();",
      "        let cap = n.next_power_of_two();",
      "        let mut lazy = Vec::with_capacity(2 * cap - 1);",
      "        lazy.resize(cap - 1, Op::id());",
      "        lazy.extend(vals.iter().cloned().map(|x| x.into()));",
      "        lazy.resize(2 * cap - 1, Op::id());",
      "        DualSegmentTree {",
      "            height: cap.trailing_zeros() as usize + 1,",
      "            n,",
      "            cap,",
      "            lazy,",
      "        }",
      "    }",
      "    fn apply(&mut self, idx: usize, p: &Op) {",
      "        self.lazy[idx] = Op::op(p, &self.lazy[idx]);",
      "    }",
      "    fn push(&mut self, parent_idx: usize) {",
      "        let left_idx = 2 * (parent_idx + 1) - 1;",
      "        let right_idx = 2 * (parent_idx + 1);",
      "        if left_idx < self.lazy.len() {",
      "            let l = self.lazy[parent_idx].clone();",
      "            self.apply(left_idx, &l);",
      "            self.apply(right_idx, &l);",
      "            self.lazy[parent_idx] = Op::id();",
      "        }",
      "    }",
      "    fn push_all(&mut self, idx: usize) {",
      "        for i in (1..(idx + 2).next_power_of_two().trailing_zeros()).rev() {",
      "            self.push(((idx + 1) >> i) - 1);",
      "        }",
      "    }",
      "    fn get(&mut self, pos: usize) -> Op {",
      "        let idx = self.cap - 1 + pos;",
      "        self.push_all(idx);",
      "        self.lazy[idx].clone()",
      "    }",
      "    fn set<T>(&mut self, pos: usize, p: T)",
      "    where",
      "        T: Into<Op>,",
      "    {",
      "        let idx = self.cap - 1 + pos;",
      "        self.push_all(idx);",
      "        self.lazy[idx] = p.into();",
      "    }",
      "    fn update<T>(&mut self, r: impl std::ops::RangeBounds<usize>, p: T)",
      "    where",
      "        T: Into<Op>,",
      "    {",
      "        let (a, b) = range(r, self.n);",
      "        let p = p.into();",
      "        let mut left_idx = a + self.cap - 1;",
      "        let mut right_idx = b + self.cap - 1;",
      "        self.push_all(((left_idx + 1) >> (left_idx + 1).trailing_zeros()) - 1);",
      "        self.push_all(((right_idx + 1) >> (right_idx + 1).trailing_zeros()) - 1);",
      "        while left_idx < right_idx {",
      "            if left_idx % 2 == 0 {",
      "                self.apply(left_idx, &p);",
      "            }",
      "            if right_idx % 2 == 0 {",
      "                self.apply(right_idx - 1, &p);",
      "            }",
      "            left_idx = left_idx >> 1;",
      "            right_idx = (right_idx - 1) >> 1;",
      "        }",
      "    }",
      "}",
      "macro_rules! define_monoid {",
      "    (\\$ name : ident , \\$ t : ty , \\$ id : expr , \\$ op : expr ) => {",
      "        #[derive(Clone, Copy, Debug)]",
      "        struct \\$name(\\$t);",
      "        impl Monoid for \\$name {",
      "            fn id() -> Self {",
      "                Self(\\$id)",
      "            }",
      "            fn op(&self, rhs: &Self) -> Self {",
      "                Self((\\$op)(self.0, rhs.0))",
      "            }",
      "        }",
      "        impl From<\\$t> for \\$name {",
      "            fn from(x: \\$t) -> \\$name {",
      "                Self(x)",
      "            }",
      "        }",
      "    };",
      "}"
    ]
  },
  "fact": {
    "prefix": "fact",
    "body": [
      "#[allow(dead_code)]",
      "fn generate_fact(n: usize) -> (Vec<usize>, Vec<usize>, Vec<usize>) {",
      "    let fact: Vec<_> = std::iter::once(1)",
      "        .chain((1..=n).scan(1, |f, i| {",
      "            *f = *f * i % M;",
      "            Some(*f)",
      "        }))",
      "        .collect();",
      "    let inv = (2..=n).fold(vec![1, 1], |mut inv, i| {",
      "        inv.push((M - (M / i) * inv[M % i] % M) % M);",
      "        inv",
      "    });",
      "    let inv_fact: Vec<_> = inv",
      "        .iter()",
      "        .scan(1, |f, i| {",
      "            *f = *f * i % M;",
      "            Some(*f)",
      "        })",
      "        .collect();",
      "    (fact, inv_fact, inv)",
      "}"
    ]
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "mod detail {",
      "    #[allow(dead_code)]",
      "    #[derive(Clone, Copy, Debug)]",
      "    pub struct Edge<W = ()>",
      "    where",
      "        W: Copy,",
      "    {",
      "        pub from: usize,",
      "        pub to: usize,",
      "        pub label: W,",
      "    }",
      "    #[allow(dead_code)]",
      "    impl<W> Edge<W>",
      "    where",
      "        W: Copy,",
      "    {",
      "        pub fn new(from: usize, to: usize) -> Self",
      "        where",
      "            W: Default,",
      "        {",
      "            Self {",
      "                from,",
      "                to,",
      "                label: W::default(),",
      "            }",
      "        }",
      "        pub fn new_with_label(from: usize, to: usize, label: W) -> Self {",
      "            Self { from, to, label }",
      "        }",
      "        pub fn rev(&self) -> Self {",
      "            Self {",
      "                from: self.to,",
      "                to: self.from,",
      "                ..*self",
      "            }",
      "        }",
      "        pub fn offset1(&self) -> Self {",
      "            Self {",
      "                from: self.from - 1,",
      "                to: self.to - 1,",
      "                ..*self",
      "            }",
      "        }",
      "    }",
      "    type Weight = usize;",
      "    pub type UnweightedEdge = Edge<()>;",
      "    pub type WeightedEdge = Edge<Weight>;",
      "    impl std::convert::From<(usize, usize)> for UnweightedEdge {",
      "        fn from(t: (usize, usize)) -> Self {",
      "            UnweightedEdge::new(t.0, t.1)",
      "        }",
      "    }",
      "    impl std::convert::From<&(usize, usize)> for UnweightedEdge {",
      "        fn from(t: &(usize, usize)) -> Self {",
      "            Edge::from(*t)",
      "        }",
      "    }",
      "    impl std::convert::From<(usize, usize, Weight)> for WeightedEdge {",
      "        fn from(t: (usize, usize, Weight)) -> Self {",
      "            Edge::new_with_label(t.0, t.1, t.2)",
      "        }",
      "    }",
      "    impl std::convert::From<&(usize, usize, Weight)> for WeightedEdge {",
      "        fn from(t: &(usize, usize, Weight)) -> Self {",
      "            Edge::from(*t)",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[derive(Clone, Debug)]",
      "    pub struct Graph<W = ()>",
      "    where",
      "        W: Copy,",
      "    {",
      "        pub out_edges: Vec<Vec<Edge<W>>>,",
      "        pub in_edges: Vec<Vec<Edge<W>>>,",
      "    }",
      "    #[allow(dead_code)]",
      "    pub type UnweightedGraph = Graph<()>;",
      "    #[allow(dead_code)]",
      "    pub type WeightedGraph = Graph<Weight>;",
      "    #[allow(dead_code)]",
      "    impl<W: Copy> Graph<W> {",
      "        pub fn new(n: usize) -> Self {",
      "            Self {",
      "                out_edges: vec![vec![]; n],",
      "                in_edges: vec![vec![]; n],",
      "            }",
      "        }",
      "        pub fn from_edges_directed<T, I>(n: usize, edges: I) -> Self",
      "        where",
      "            I: IntoIterator<Item = T>,",
      "            T: std::convert::Into<Edge<W>>,",
      "        {",
      "            let mut g = Graph::new(n);",
      "            for edge in edges {",
      "                let e = edge.into();",
      "                g.add_edge(e);",
      "            }",
      "            g",
      "        }",
      "        pub fn from_edges1_directed<T, I>(n: usize, edges: I) -> Self",
      "        where",
      "            I: IntoIterator<Item = T>,",
      "            T: std::convert::Into<Edge<W>>,",
      "        {",
      "            Graph::from_edges_directed(n, edges.into_iter().map(|e| e.into()).map(|e| e.offset1()))",
      "        }",
      "        pub fn from_edges_undirected<T, I>(n: usize, edges: I) -> Self",
      "        where",
      "            I: IntoIterator<Item = T>,",
      "            T: std::convert::Into<Edge<W>>,",
      "        {",
      "            Graph::from_edges_directed(",
      "                n,",
      "                edges",
      "                    .into_iter()",
      "                    .map(|e| e.into())",
      "                    .flat_map(|e| std::iter::once(e).chain(std::iter::once(e.rev()))),",
      "            )",
      "        }",
      "        pub fn from_edges1_undirected<T, I>(n: usize, edges: I) -> Self",
      "        where",
      "            I: IntoIterator<Item = T>,",
      "            T: std::convert::Into<Edge<W>>,",
      "        {",
      "            Graph::from_edges1_directed(",
      "                n,",
      "                edges",
      "                    .into_iter()",
      "                    .map(|e| e.into())",
      "                    .flat_map(|e| std::iter::once(e).chain(std::iter::once(e.rev()))),",
      "            )",
      "        }",
      "        pub fn size(&self) -> usize {",
      "            self.out_edges.len()",
      "        }",
      "        pub fn add_edge<T>(&mut self, e: T)",
      "        where",
      "            Edge<W>: std::convert::From<T>,",
      "        {",
      "            let edge = Edge::from(e);",
      "            self.out_edges[edge.from].push(edge);",
      "            self.in_edges[edge.to].push(edge);",
      "        }",
      "        pub fn adjs<'a>(&'a self, v: usize) -> impl 'a + DoubleEndedIterator<Item = usize> {",
      "            self.out_edges[v].iter().map(|e| e.to)",
      "        }",
      "        pub fn children<'a>(",
      "            &'a self,",
      "            v: usize,",
      "            p: usize,",
      "        ) -> impl 'a + DoubleEndedIterator<Item = usize> {",
      "            self.adjs(v).filter(move |&u| u != p)",
      "        }",
      "        pub fn children_edge<'a>(",
      "            &'a self,",
      "            v: usize,",
      "            p: usize,",
      "        ) -> impl 'a + DoubleEndedIterator<Item = Edge<W>> {",
      "            self.out_edges[v].iter().copied().filter(move |e| e.to != p)",
      "        }",
      "    }",
      "}"
    ]
  },
  "graph_dfs": {
    "prefix": "graph_dfs",
    "body": [
      "#[allow(dead_code)]",
      "fn dfs(g: &Graph, src: usize) {",
      "    let mut visited = vec![false; g.size()];",
      "    let mut stack = vec![src];",
      "    visited[src] = true;",
      "    while let Some(v) = stack.pop() {",
      "        g.out_edges[v]",
      "            .iter()",
      "            .map(|e| e.to)",
      "            .filter(|&u| !std::mem::replace(&mut visited[u], true))",
      "            .for_each(|u| stack.push(u));",
      "    }",
      "}"
    ]
  },
  "graph_dfs_recursive": {
    "prefix": "graph_dfs_recursive",
    "body": [
      "#[allow(dead_code)]",
      "fn dfs(g: &Graph, v: usize, visited: &mut [bool]) {",
      "    if visited[v] {",
      "        return;",
      "    }",
      "    visited[v] = true;",
      "    for &edge in &g.out_edges[v] {",
      "        dfs(g, edge.to, visited);",
      "    }",
      "}"
    ]
  },
  "iteratorext": {
    "prefix": "iteratorext",
    "body": [
      "trait IteratorExt: Iterator + Sized {",
      "    fn fold_vec<T, F>(self: Self, init: Vec<T>, f: F) -> Vec<T>",
      "    where",
      "        F: FnMut(Self::Item) -> (usize, T);",
      "    fn fold_vec2<T, F>(self: Self, init: Vec<T>, f: F) -> Vec<T>",
      "    where",
      "        F: FnMut(&Vec<T>, Self::Item) -> (usize, T);",
      "    fn fold_vec3<T, F>(self: Self, init: Vec<T>, f: F) -> Vec<T>",
      "    where",
      "        F: FnMut(&Vec<T>, Self::Item) -> T;",
      "}",
      "impl<I> IteratorExt for I",
      "where",
      "    I: Iterator,",
      "{",
      "    fn fold_vec<T, F>(self: Self, init: Vec<T>, mut f: F) -> Vec<T>",
      "    where",
      "        F: FnMut(Self::Item) -> (usize, T),",
      "    {",
      "        self.fold(init, |mut v, item| {",
      "            let (idx, t) = f(item);",
      "            v[idx] = t;",
      "            v",
      "        })",
      "    }",
      "    fn fold_vec2<T, F>(self: Self, init: Vec<T>, mut f: F) -> Vec<T>",
      "    where",
      "        F: FnMut(&Vec<T>, Self::Item) -> (usize, T),",
      "    {",
      "        self.fold(init, |mut v, item| {",
      "            let (idx, t) = f(&v, item);",
      "            v[idx] = t;",
      "            v",
      "        })",
      "    }",
      "    fn fold_vec3<T, F>(self: Self, init: Vec<T>, mut f: F) -> Vec<T>",
      "    where",
      "        F: FnMut(&Vec<T>, Self::Item) -> T,",
      "    {",
      "        self.fold(init, |mut v, item| {",
      "            let t = f(&v, item);",
      "            v.push(t);",
      "            v",
      "        })",
      "    }",
      "}"
    ]
  },
  "iteratorpick": {
    "prefix": "iteratorpick",
    "body": [
      "trait Pick0 {",
      "    type Output;",
      "    fn pick0(self) -> Self::Output;",
      "}",
      "impl<T, T2> Pick0 for (T, T2) {",
      "    type Output = T;",
      "    fn pick0(self) -> Self::Output {",
      "        self.0",
      "    }",
      "}",
      "impl<T, T2, T3> Pick0 for (T, T2, T3) {",
      "    type Output = T;",
      "    fn pick0(self) -> Self::Output {",
      "        self.0",
      "    }",
      "}",
      "trait IteratorPick0Ext<T>: std::iter::Iterator<Item = T> + std::marker::Sized",
      "where",
      "    T: Pick0,",
      "{",
      "    fn pick0(self) -> std::iter::Map<Self, fn(T) -> T::Output> {",
      "        self.map(Pick0::pick0)",
      "    }",
      "}",
      "impl<T, I> IteratorPick0Ext<T> for I",
      "where",
      "    I: std::iter::Iterator<Item = T>,",
      "    T: Pick0,",
      "{",
      "}",
      "trait Pick1 {",
      "    type Output;",
      "    fn pick1(self) -> Self::Output;",
      "}",
      "impl<T, T2> Pick1 for (T, T2) {",
      "    type Output = T2;",
      "    fn pick1(self) -> Self::Output {",
      "        self.1",
      "    }",
      "}",
      "impl<T, T2, T3> Pick1 for (T, T2, T3) {",
      "    type Output = T2;",
      "    fn pick1(self) -> Self::Output {",
      "        self.1",
      "    }",
      "}",
      "trait IteratorPick1Ext<T>: std::iter::Iterator<Item = T> + std::marker::Sized",
      "where",
      "    T: Pick1,",
      "{",
      "    fn pick1(self) -> std::iter::Map<Self, fn(T) -> T::Output> {",
      "        self.map(Pick1::pick1)",
      "    }",
      "}",
      "impl<T, I> IteratorPick1Ext<T> for I",
      "where",
      "    I: std::iter::Iterator<Item = T>,",
      "    T: Pick1,",
      "{",
      "}"
    ]
  },
  "lazysegtree": {
    "prefix": "lazysegtree",
    "body": [
      "fn range(r: impl std::ops::RangeBounds<usize>, n: usize) -> (usize, usize) {",
      "    let start = match r.start_bound() {",
      "        std::ops::Bound::Excluded(&i) => i + 1,",
      "        std::ops::Bound::Included(&i) => i,",
      "        std::ops::Bound::Unbounded => 0,",
      "    };",
      "    let end = match r.end_bound() {",
      "        std::ops::Bound::Excluded(&i) => i,",
      "        std::ops::Bound::Included(&i) => i + 1,",
      "        std::ops::Bound::Unbounded => n,",
      "    };",
      "    (start, end)",
      "}",
      "trait Monoid {",
      "    fn id() -> Self;",
      "    fn op(&self, rhs: &Self) -> Self;",
      "}",
      "#[derive(Debug)]",
      "struct LazySegmentTree<M, Op>",
      "where",
      "    M: Monoid,",
      "    Op: Monoid,",
      "{",
      "    height: usize,",
      "    n: usize,",
      "    cap: usize,",
      "    values: Vec<M>,",
      "    lazy: Vec<Op>,",
      "}",
      "trait Operator<T>: Monoid {",
      "    fn apply(&self, v: &T) -> T;",
      "}",
      "#[allow(dead_code)]",
      "impl<M, Op> LazySegmentTree<M, Op>",
      "where",
      "    M: Monoid + Clone,",
      "    Op: Monoid + Operator<M> + Clone,",
      "{",
      "    fn new(n: usize) -> Self {",
      "        let cap = n.next_power_of_two();",
      "        LazySegmentTree {",
      "            height: cap.trailing_zeros() as usize + 1,",
      "            n,",
      "            cap,",
      "            values: vec![M::id(); 2 * cap - 1],",
      "            lazy: vec![Op::id(); 2 * cap - 1],",
      "        }",
      "    }",
      "    fn with<T>(vals: &[T]) -> Self",
      "    where",
      "        T: Into<M> + Clone,",
      "    {",
      "        let n = vals.len();",
      "        let cap = n.next_power_of_two();",
      "        let mut values = Vec::with_capacity(2 * cap - 1);",
      "        values.resize(cap - 1, M::id());",
      "        values.extend(vals.iter().cloned().map(|x| x.into()));",
      "        values.resize(2 * cap - 1, M::id());",
      "        let mut st = LazySegmentTree {",
      "            height: cap.trailing_zeros() as usize + 1,",
      "            n,",
      "            cap,",
      "            values,",
      "            lazy: vec![Op::id(); 2 * cap - 1],",
      "        };",
      "        for idx in (0..cap - 1).rev() {",
      "            st.fix(idx);",
      "        }",
      "        st",
      "    }",
      "    fn fix(&mut self, idx: usize) {",
      "        let left_idx = 2 * (idx + 1) - 1;",
      "        let right_idx = 2 * (idx + 1);",
      "        if left_idx < self.values.len() {",
      "            self.values[idx] = Op::apply(",
      "                &self.lazy[idx],",
      "                &M::op(&self.values[left_idx], &self.values[right_idx]),",
      "            );",
      "        }",
      "    }",
      "    fn fix_all(&mut self, mut idx: usize) {",
      "        while idx > 0 {",
      "            idx = (idx - 1) / 2;",
      "            self.fix(idx);",
      "        }",
      "    }",
      "    fn apply(&mut self, idx: usize, p: &Op) {",
      "        self.lazy[idx] = Op::op(p, &self.lazy[idx]);",
      "        self.values[idx] = Op::apply(p, &self.values[idx]);",
      "    }",
      "    fn push(&mut self, parent_idx: usize) {",
      "        let left_idx = 2 * (parent_idx + 1) - 1;",
      "        let right_idx = 2 * (parent_idx + 1);",
      "        if left_idx < self.values.len() {",
      "            let l = self.lazy[parent_idx].clone();",
      "            self.apply(left_idx, &l);",
      "            self.apply(right_idx, &l);",
      "            self.lazy[parent_idx] = Op::id();",
      "        }",
      "    }",
      "    fn push_all(&mut self, idx: usize) {",
      "        for i in (1..(idx + 2).next_power_of_two().trailing_zeros()).rev() {",
      "            self.push(((idx + 1) >> i) - 1);",
      "        }",
      "    }",
      "    fn get(&mut self, pos: usize) -> M {",
      "        let idx = self.cap - 1 + pos;",
      "        self.push_all(idx);",
      "        self.values[idx].clone()",
      "    }",
      "    fn set<T>(&mut self, pos: usize, v: T)",
      "    where",
      "        T: Into<M>,",
      "    {",
      "        let idx = self.cap - 1 + pos;",
      "        self.push_all(idx);",
      "        self.values[idx] = v.into();",
      "        self.lazy[idx] = Op::id();",
      "        self.fix_all(idx);",
      "    }",
      "    fn update<T>(&mut self, r: impl std::ops::RangeBounds<usize>, p: T)",
      "    where",
      "        T: Into<Op>,",
      "    {",
      "        let (a, b) = range(r, self.n);",
      "        let p = p.into();",
      "        let mut left_idx = a + self.cap - 1;",
      "        let mut right_idx = b + self.cap - 1;",
      "        self.push_all(((left_idx + 1) >> (left_idx + 1).trailing_zeros()) - 1);",
      "        self.push_all(((right_idx + 1) >> (right_idx + 1).trailing_zeros()) - 1);",
      "        while left_idx < right_idx {",
      "            if left_idx % 2 == 0 {",
      "                self.apply(left_idx, &p);",
      "            }",
      "            if right_idx % 2 == 0 {",
      "                self.apply(right_idx - 1, &p);",
      "            }",
      "            left_idx = left_idx >> 1;",
      "            right_idx = (right_idx - 1) >> 1;",
      "        }",
      "        self.fix_all(a + self.cap - 1);",
      "        self.fix_all(b + self.cap - 1);",
      "    }",
      "    fn query(&mut self, r: impl std::ops::RangeBounds<usize>) -> M {",
      "        let (a, b) = range(r, self.n);",
      "        let mut left = M::id();",
      "        let mut right = M::id();",
      "        let mut left_idx = a + self.cap - 1;",
      "        let mut right_idx = b + self.cap - 1;",
      "        self.push_all(((left_idx + 1) >> (left_idx + 1).trailing_zeros()) - 1);",
      "        self.push_all(((right_idx + 1) >> (right_idx + 1).trailing_zeros()) - 1);",
      "        while left_idx < right_idx {",
      "            if left_idx % 2 == 0 {",
      "                left = M::op(&left, &self.values[left_idx]);",
      "                left_idx += 1;",
      "            }",
      "            if right_idx % 2 == 0 {",
      "                right = M::op(&self.values[right_idx - 1], &right);",
      "                right_idx -= 1;",
      "            }",
      "            left_idx = left_idx >> 1;",
      "            right_idx = (right_idx - 1) >> 1;",
      "        }",
      "        M::op(&left, &right)",
      "    }",
      "}",
      "macro_rules! define_monoid {",
      "    (\\$ name : ident , \\$ t : ty , \\$ id : expr , \\$ op : expr ) => {",
      "        #[derive(Clone, Copy, Debug)]",
      "        struct \\$name(\\$t);",
      "        impl Monoid for \\$name {",
      "            fn id() -> Self {",
      "                Self(\\$id)",
      "            }",
      "            fn op(&self, rhs: &Self) -> Self {",
      "                Self((\\$op)(self.0, rhs.0))",
      "            }",
      "        }",
      "        impl From<\\$t> for \\$name {",
      "            fn from(x: \\$t) -> \\$name {",
      "                Self(x)",
      "            }",
      "        }",
      "    };",
      "}"
    ]
  },
  "lowerbound": {
    "prefix": "lowerbound",
    "body": [
      "#[allow(dead_code)]",
      "fn lower_bound<T, F>(mut begin: T, mut end: T, epsilon: T, f: F) -> T",
      "where",
      "    T: std::marker::Copy",
      "        + std::ops::Add<T, Output = T>",
      "        + std::ops::Sub<T, Output = T>",
      "        + std::ops::Div<T, Output = T>",
      "        + std::cmp::PartialOrd<T>",
      "        + std::convert::TryFrom<i32>,",
      "    F: Fn(T) -> std::cmp::Ordering,",
      "{",
      "    let two = T::try_from(2).ok().unwrap();",
      "    while end - begin >= epsilon {",
      "        let mid = begin + (end - begin) / two;",
      "        match f(mid) {",
      "            std::cmp::Ordering::Less => {",
      "                begin = mid + epsilon;",
      "            }",
      "            _ => {",
      "                end = mid;",
      "            }",
      "        }",
      "    }",
      "    begin",
      "}"
    ]
  },
  "lowerboundint": {
    "prefix": "lowerboundint",
    "body": [
      "#[allow(dead_code)]",
      "fn lower_bound<T, F>(mut begin: T, mut end: T, epsilon: T, f: F) -> T",
      "where",
      "    T: std::marker::Copy",
      "        + std::ops::Add<T, Output = T>",
      "        + std::ops::Sub<T, Output = T>",
      "        + std::ops::Div<T, Output = T>",
      "        + std::cmp::PartialOrd<T>",
      "        + std::convert::TryFrom<i32>,",
      "    F: Fn(T) -> std::cmp::Ordering,",
      "{",
      "    let two = T::try_from(2).ok().unwrap();",
      "    while end - begin >= epsilon {",
      "        let mid = begin + (end - begin) / two;",
      "        match f(mid) {",
      "            std::cmp::Ordering::Less => {",
      "                begin = mid + epsilon;",
      "            }",
      "            _ => {",
      "                end = mid;",
      "            }",
      "        }",
      "    }",
      "    begin",
      "}",
      "#[allow(dead_code)]",
      "fn lower_bound_int<T, F>(begin: T, end: T, f: F) -> T",
      "where",
      "    T: std::marker::Copy",
      "        + std::ops::Add<T, Output = T>",
      "        + std::ops::Sub<T, Output = T>",
      "        + std::ops::Div<T, Output = T>",
      "        + std::cmp::PartialOrd<T>",
      "        + std::convert::TryFrom<i32>,",
      "    F: Fn(T) -> std::cmp::Ordering,",
      "{",
      "    lower_bound(begin, end, T::try_from(1).ok().unwrap(), f)",
      "}"
    ]
  },
  "modulo": {
    "prefix": "modulo",
    "body": [
      "use num::{One, Zero};",
      "#[allow(dead_code)]",
      "pub fn pow_mod(mut x: usize, mut p: usize, m: usize) -> usize {",
      "    let mut y = 1;",
      "    x = x % m;",
      "    while p > 0 {",
      "        if p & 1 > 0 {",
      "            y = y * x % m;",
      "        }",
      "        x = x * x % m;",
      "        p >>= 1;",
      "    }",
      "    y",
      "}",
      "pub trait Modulus: Copy + Eq {",
      "    fn modulus() -> usize;",
      "}",
      "macro_rules! define_static_mod {",
      "    (\\$ m : expr , \\$ modulus : ident , \\$ mod : ident ) => {",
      "        #[derive(Clone, Copy, PartialEq, Eq, Debug)]",
      "        pub struct \\$modulus();",
      "        impl Modulus for \\$modulus {",
      "            fn modulus() -> usize {",
      "                \\$m",
      "            }",
      "        }",
      "        #[allow(dead_code)]",
      "        pub type \\$mod = Mod<\\$modulus>;",
      "    };",
      "}",
      "define_static_mod!(2013265921, Modulus2013265921, Mod2013265921);",
      "define_static_mod!(1811939329, Modulus1811939329, Mod1811939329);",
      "define_static_mod!(469762049, Modulus469762049, Mod469762049);",
      "define_static_mod!(998244353, Modulus998244353, Mod998244353);",
      "define_static_mod!(1224736769, Modulus1224736769, Mod1224736769);",
      "define_static_mod!(1000000007, Modulus1000000007, Mod1000000007);",
      "#[derive(Clone, Copy, PartialEq, Eq)]",
      "pub struct Mod<M>(pub usize, std::marker::PhantomData<fn() -> M>);",
      "#[allow(dead_code)]",
      "impl<M: Modulus> Mod<M> {",
      "    pub fn modulus() -> usize {",
      "        M::modulus()",
      "    }",
      "    pub fn new(n: usize) -> Self {",
      "        Mod(n % M::modulus(), std::marker::PhantomData)",
      "    }",
      "    pub fn pow(self, p: usize) -> Self {",
      "        Mod::new(pow_mod(self.0, p, M::modulus()))",
      "    }",
      "    pub fn inv(self) -> Self {",
      "        let (_zero, g, _u, v) = std::iter::successors(",
      "            Some((self.0 as i64, M::modulus() as i64, 1, 0)),",
      "            |&(a, b, u, v)| {",
      "                if a == 0 {",
      "                    None",
      "                } else {",
      "                    Some((b % a, a, -u * (b / a) + v, u))",
      "                }",
      "            },",
      "        )",
      "        .last()",
      "        .unwrap();",
      "        assert_eq!(",
      "            g,",
      "            1,",
      "            \"gcd({}, {}) must be 1 but {}.\",",
      "            self.0,",
      "            M::modulus(),",
      "            g",
      "        );",
      "        Mod::new((v + M::modulus() as i64) as usize)",
      "    }",
      "}",
      "impl<M> std::fmt::Display for Mod<M> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl<M> std::fmt::Debug for Mod<M> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl<T, M: Modulus> std::convert::From<T> for Mod<M>",
      "where",
      "    usize: std::convert::TryFrom<T>,",
      "    T: num::traits::Unsigned,",
      "{",
      "    fn from(v: T) -> Self {",
      "        use std::convert::TryFrom;",
      "        Mod::new(usize::try_from(v).ok().unwrap())",
      "    }",
      "}",
      "impl<M: Modulus> std::str::FromStr for Mod<M> {",
      "    type Err = <usize as std::str::FromStr>::Err;",
      "    fn from_str(s: &str) -> Result<Self, Self::Err> {",
      "        usize::from_str(s).map(|n| Mod::new(n))",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Neg for Mod<M> {",
      "    type Output = Self;",
      "    fn neg(self) -> Self {",
      "        Mod::new(M::modulus() - self.0)",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Add<Mod<M>> for Mod<M> {",
      "    type Output = Self;",
      "    fn add(self, rhs: Mod<M>) -> Self {",
      "        Mod::new(self.0 + rhs.0)",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Add<usize> for Mod<M> {",
      "    type Output = Self;",
      "    fn add(self, rhs: usize) -> Self {",
      "        Mod::new(self.0 + rhs)",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Add<Mod<M>> for usize {",
      "    type Output = Mod<M>;",
      "    fn add(self, rhs: Mod<M>) -> Mod<M> {",
      "        Mod::new(self + rhs.0)",
      "    }",
      "}",
      "impl<T, M: Modulus> std::ops::AddAssign<T> for Mod<M>",
      "where",
      "    Mod<M>: std::ops::Add<T, Output = Mod<M>>,",
      "{",
      "    fn add_assign(&mut self, rhs: T) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Sub<Mod<M>> for Mod<M> {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Mod<M>) -> Self {",
      "        Mod::new(self.0 + M::modulus() - rhs.0)",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Sub<usize> for Mod<M> {",
      "    type Output = Self;",
      "    fn sub(self, rhs: usize) -> Self {",
      "        Mod::new(self.0 + M::modulus() - rhs % M::modulus())",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Sub<Mod<M>> for usize {",
      "    type Output = Mod<M>;",
      "    fn sub(self, rhs: Mod<M>) -> Mod<M> {",
      "        Mod::new(self + M::modulus() - rhs.0)",
      "    }",
      "}",
      "impl<T, M: Modulus> std::ops::SubAssign<T> for Mod<M>",
      "where",
      "    Mod<M>: std::ops::Sub<T, Output = Mod<M>>,",
      "{",
      "    fn sub_assign(&mut self, rhs: T) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Mul<Mod<M>> for Mod<M> {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Mod<M>) -> Self {",
      "        Mod::new(self.0 * rhs.0)",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Mul<usize> for Mod<M> {",
      "    type Output = Self;",
      "    fn mul(self, rhs: usize) -> Self {",
      "        Mod::new(self.0 * (rhs % M::modulus()))",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Mul<Mod<M>> for usize {",
      "    type Output = Mod<M>;",
      "    fn mul(self, rhs: Mod<M>) -> Mod<M> {",
      "        Mod::new((self % M::modulus()) * rhs.0)",
      "    }",
      "}",
      "impl<T, M: Modulus> std::ops::MulAssign<T> for Mod<M>",
      "where",
      "    Mod<M>: std::ops::Mul<T, Output = Mod<M>>,",
      "{",
      "    fn mul_assign(&mut self, rhs: T) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Div<Mod<M>> for Mod<M> {",
      "    type Output = Self;",
      "    fn div(self, rhs: Mod<M>) -> Self {",
      "        if self.0 == 0 {",
      "            self",
      "        } else {",
      "            self * rhs.inv()",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Div<usize> for Mod<M> {",
      "    type Output = Self;",
      "    fn div(self, rhs: usize) -> Self {",
      "        if self.0 == 0 {",
      "            self",
      "        } else {",
      "            self * Mod::new(rhs).inv()",
      "        }",
      "    }",
      "}",
      "impl<M: Modulus> std::ops::Div<Mod<M>> for usize {",
      "    type Output = Mod<M>;",
      "    fn div(self, rhs: Mod<M>) -> Mod<M> {",
      "        if self == 0 {",
      "            Mod::new(self)",
      "        } else {",
      "            self * rhs.inv()",
      "        }",
      "    }",
      "}",
      "impl<T, M: Modulus> std::ops::DivAssign<T> for Mod<M>",
      "where",
      "    Mod<M>: std::ops::Div<T, Output = Mod<M>>,",
      "{",
      "    fn div_assign(&mut self, rhs: T) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl<M: Modulus> std::iter::Product for Mod<M> {",
      "    fn product<I>(iter: I) -> Self",
      "    where",
      "        I: Iterator<Item = Self>,",
      "    {",
      "        iter.fold(Mod::one(), |p, a| p * a)",
      "    }",
      "}",
      "impl<M: Modulus> std::iter::Sum for Mod<M> {",
      "    fn sum<I>(iter: I) -> Self",
      "    where",
      "        I: Iterator<Item = Self>,",
      "    {",
      "        iter.fold(Mod::zero(), |p, a| p + a)",
      "    }",
      "}",
      "impl<M: Modulus> num::Zero for Mod<M> {",
      "    fn zero() -> Self {",
      "        Mod::new(0)",
      "    }",
      "    fn is_zero(&self) -> bool {",
      "        self.0 == 0",
      "    }",
      "}",
      "impl<M: Modulus> num::One for Mod<M> {",
      "    fn one() -> Self {",
      "        Mod::new(1)",
      "    }",
      "    fn is_one(&self) -> bool {",
      "        self.0 == 1",
      "    }",
      "}"
    ]
  },
  "modulo_fact": {
    "prefix": "modulo_fact",
    "body": [
      "#[allow(dead_code)]",
      "fn generate_fact<M: Modulus>(n: usize) -> (Vec<Mod<M>>, Vec<Mod<M>>, Vec<Mod<M>>) {",
      "    let fact: Vec<_> = std::iter::once(Mod::one())",
      "        .chain((1..=n).scan(Mod::one(), |f, i| {",
      "            *f = *f * i;",
      "            Some(*f)",
      "        }))",
      "        .collect();",
      "    let inv = (2..=n).fold(vec![Mod::one(), Mod::one()], |mut inv, i| {",
      "        inv.push(-Mod::new(M::modulus() / i) * inv[M::modulus() % i]);",
      "        inv",
      "    });",
      "    let inv_fact: Vec<_> = inv",
      "        .iter()",
      "        .copied()",
      "        .scan(Mod::one(), |f, i| {",
      "            *f = *f * i;",
      "            Some(*f)",
      "        })",
      "        .collect();",
      "    (fact, inv, inv_fact)",
      "}"
    ]
  },
  "multiset": {
    "prefix": "multiset",
    "body": [
      "#[derive(Clone, Debug, Default, PartialEq, Eq)]",
      "struct BTreeMultiSet<T>",
      "where",
      "    T: Ord,",
      "{",
      "    length: usize,",
      "    m: std::collections::BTreeMap<T, usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl<T> BTreeMultiSet<T>",
      "where",
      "    T: Ord,",
      "{",
      "    fn new() -> BTreeMultiSet<T> {",
      "        Self {",
      "            length: 0,",
      "            m: std::collections::BTreeMap::new(),",
      "        }",
      "    }",
      "    fn is_empty(&self) -> bool {",
      "        self.m.is_empty()",
      "    }",
      "    fn contains<Q>(&self, value: &Q) -> bool",
      "    where",
      "        Q: Ord + ?Sized,",
      "        T: std::borrow::Borrow<Q>,",
      "    {",
      "        self.m.contains_key(value)",
      "    }",
      "    fn len(&self) -> usize {",
      "        self.length",
      "    }",
      "    fn count<Q>(&self, value: &Q) -> usize",
      "    where",
      "        Q: Ord + ?Sized,",
      "        T: std::borrow::Borrow<Q>,",
      "    {",
      "        *self.m.get(value).unwrap_or(&0)",
      "    }",
      "    fn get<Q>(&self, value: &Q) -> Option<&T>",
      "    where",
      "        Q: Ord + ?Sized,",
      "        T: std::borrow::Borrow<Q>,",
      "    {",
      "        self.m.get_key_value(value).map(|(k, _v)| k)",
      "    }",
      "    fn first(&self) -> Option<&T> {",
      "        self.m.iter().next().map(|(k, _v)| k)",
      "    }",
      "    fn last(&self) -> Option<&T> {",
      "        self.m.iter().next_back().map(|(k, _v)| k)",
      "    }",
      "    fn clear(&mut self) {",
      "        self.length = 0;",
      "        self.m.clear();",
      "    }",
      "    fn insert(&mut self, value: T) {",
      "        self.length += 1;",
      "        *self.m.entry(value).or_insert(0) += 1;",
      "    }",
      "    fn append(&mut self, other: &mut BTreeMultiSet<T>) {",
      "        self.length += other.length;",
      "        other.length = 0;",
      "        std::mem::take(&mut other.m).into_iter().for_each(|(k, v)| {",
      "            *self.m.entry(k).or_insert(0) += v;",
      "        });",
      "    }",
      "    fn remove<Q>(&mut self, value: &Q) -> bool",
      "    where",
      "        Q: Ord + ?Sized,",
      "        T: std::borrow::Borrow<Q>,",
      "    {",
      "        if let Some(c) = self.m.get_mut(value) {",
      "            self.length -= 1;",
      "            *c -= 1;",
      "            if *c == 0 {",
      "                self.m.remove(value);",
      "            }",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "    fn iter(&self) -> impl DoubleEndedIterator<Item = &T> {",
      "        self.m.iter().flat_map(|(v, m)| (0..*m).map(move |_| v))",
      "    }",
      "    fn range<'a, K, R>(&'a self, range: R) -> impl 'a + DoubleEndedIterator<Item = &T>",
      "    where",
      "        K: Ord + ?Sized,",
      "        R: std::ops::RangeBounds<K>,",
      "        T: std::borrow::Borrow<K>,",
      "    {",
      "        self.m",
      "            .range(range)",
      "            .flat_map(|(v, m)| (0..*m).map(move |_| v))",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "impl<T> BTreeMultiSet<T>",
      "where",
      "    T: Ord + Clone,",
      "{",
      "    fn pop_first(&mut self) -> Option<T> {",
      "        if self.is_empty() {",
      "            return None;",
      "        }",
      "        let first = self.first().unwrap().clone();",
      "        self.remove(&first);",
      "        Some(first)",
      "    }",
      "    fn pop_last(&mut self) -> Option<T> {",
      "        if self.is_empty() {",
      "            return None;",
      "        }",
      "        let last = self.last().unwrap().clone();",
      "        self.remove(&last);",
      "        Some(last)",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "impl<'a, T> Extend<&'a T> for BTreeMultiSet<T>",
      "where",
      "    T: 'a + Ord + Clone,",
      "{",
      "    fn extend<I>(&mut self, iter: I)",
      "    where",
      "        I: IntoIterator<Item = &'a T>,",
      "    {",
      "        for value in iter {",
      "            self.insert(value.clone());",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "impl<T> Extend<T> for BTreeMultiSet<T>",
      "where",
      "    T: Ord,",
      "{",
      "    fn extend<I>(&mut self, iter: I)",
      "    where",
      "        I: IntoIterator<Item = T>,",
      "    {",
      "        for value in iter {",
      "            self.insert(value);",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "impl<T> std::iter::FromIterator<T> for BTreeMultiSet<T>",
      "where",
      "    T: Ord,",
      "{",
      "    fn from_iter<I>(iter: I) -> Self",
      "    where",
      "        I: IntoIterator<Item = T>,",
      "    {",
      "        let mut set = Self::new();",
      "        set.extend(iter);",
      "        set",
      "    }",
      "}"
    ]
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "fn range(r: impl std::ops::RangeBounds<usize>, n: usize) -> (usize, usize) {",
      "    let start = match r.start_bound() {",
      "        std::ops::Bound::Excluded(&i) => i + 1,",
      "        std::ops::Bound::Included(&i) => i,",
      "        std::ops::Bound::Unbounded => 0,",
      "    };",
      "    let end = match r.end_bound() {",
      "        std::ops::Bound::Excluded(&i) => i,",
      "        std::ops::Bound::Included(&i) => i + 1,",
      "        std::ops::Bound::Unbounded => n,",
      "    };",
      "    (start, end)",
      "}",
      "trait Monoid {",
      "    fn id() -> Self;",
      "    fn op(&self, rhs: &Self) -> Self;",
      "}",
      "#[derive(Debug)]",
      "struct SegmentTree<M>",
      "where",
      "    M: Monoid,",
      "{",
      "    n: usize,",
      "    cap: usize,",
      "    values: Vec<M>,",
      "}",
      "#[allow(dead_code)]",
      "impl<M> SegmentTree<M>",
      "where",
      "    M: Monoid + Clone,",
      "{",
      "    fn new(n: usize) -> Self {",
      "        let cap = n.next_power_of_two();",
      "        SegmentTree {",
      "            n,",
      "            cap,",
      "            values: vec![M::id(); 2 * cap - 1],",
      "        }",
      "    }",
      "    fn with<T>(vals: &[T]) -> Self",
      "    where",
      "        T: Into<M> + Clone,",
      "    {",
      "        let n = vals.len();",
      "        let cap = n.next_power_of_two();",
      "        let mut values = Vec::with_capacity(2 * cap - 1);",
      "        values.resize(cap - 1, M::id());",
      "        values.extend(vals.iter().cloned().map(|x| x.into()));",
      "        values.resize(2 * cap - 1, M::id());",
      "        let mut st = SegmentTree { n, cap, values };",
      "        for idx in (0..cap - 1).rev() {",
      "            st.fix(idx);",
      "        }",
      "        st",
      "    }",
      "    fn fix(&mut self, idx: usize) {",
      "        let left_idx = 2 * (idx + 1) - 1;",
      "        let right_idx = 2 * (idx + 1);",
      "        if left_idx < self.values.len() {",
      "            self.values[idx] = M::op(&self.values[left_idx], &self.values[right_idx]);",
      "        }",
      "    }",
      "    fn fix_all(&mut self, mut idx: usize) {",
      "        while idx > 0 {",
      "            idx = (idx - 1) / 2;",
      "            self.fix(idx);",
      "        }",
      "    }",
      "    fn get(&self, pos: usize) -> M {",
      "        self.values[self.cap - 1 + pos].clone()",
      "    }",
      "    fn set<T>(&mut self, pos: usize, v: T)",
      "    where",
      "        T: Into<M>,",
      "    {",
      "        let idx = self.cap - 1 + pos;",
      "        self.values[idx] = v.into();",
      "        self.fix_all(idx);",
      "    }",
      "    fn query(&self, r: impl std::ops::RangeBounds<usize>) -> M {",
      "        let (a, b) = range(r, self.n);",
      "        let mut left = M::id();",
      "        let mut right = M::id();",
      "        let mut left_idx = a + self.cap - 1;",
      "        let mut right_idx = b + self.cap - 1;",
      "        while left_idx < right_idx {",
      "            if left_idx % 2 == 0 {",
      "                left = M::op(&left, &self.values[left_idx]);",
      "                left_idx += 1;",
      "            }",
      "            if right_idx % 2 == 0 {",
      "                right = M::op(&self.values[right_idx - 1], &right);",
      "                right_idx -= 1;",
      "            }",
      "            left_idx = left_idx >> 1;",
      "            right_idx = (right_idx - 1) >> 1;",
      "        }",
      "        M::op(&left, &right)",
      "    }",
      "    fn right_partition_point<F>(&self, a: usize, mut f: F) -> Option<usize>",
      "    where",
      "        F: FnMut(&M) -> bool,",
      "    {",
      "        assert!(a <= self.cap);",
      "        if !f(&M::id()) {",
      "            Some(a)",
      "        } else if a == self.cap {",
      "            None",
      "        } else {",
      "            let mut b = a;",
      "            let mut idx = ((b + self.cap) >> (b + self.cap).trailing_zeros()) - 1;",
      "            let mut len = 1 << (b + self.cap).trailing_zeros();",
      "            let mut val = M::id();",
      "            let mut val_next = M::op(&val, &self.values[idx]);",
      "            while f(&val_next) {",
      "                val = val_next;",
      "                b += len;",
      "                len <<= (idx + 2).trailing_zeros();",
      "                idx = ((idx + 2) >> (idx + 2).trailing_zeros()) - 1;",
      "                if idx == 0 {",
      "                    return None;",
      "                }",
      "                val_next = M::op(&val, &self.values[idx]);",
      "            }",
      "            idx = 2 * idx + 1;",
      "            len >>= 1;",
      "            while idx < self.values.len() {",
      "                val_next = M::op(&val, &self.values[idx]);",
      "                if f(&val_next) {",
      "                    val = val_next;",
      "                    b += len;",
      "                    idx += 1;",
      "                }",
      "                len >>= 1;",
      "                idx = 2 * idx + 1;",
      "            }",
      "            Some(b + 1)",
      "        }",
      "    }",
      "    fn left_partition_point<F>(&self, b: usize, mut f: F) -> Option<usize>",
      "    where",
      "        F: FnMut(&M) -> bool,",
      "    {",
      "        assert!(b <= self.cap);",
      "        if !f(&M::id()) {",
      "            None",
      "        } else if b == 0 {",
      "            Some(0)",
      "        } else {",
      "            let mut a = b;",
      "            let mut idx = (a + self.cap - 1) >> (!(a + self.cap - 1)).trailing_zeros();",
      "            let mut len = 1 << (!(a + self.cap - 1)).trailing_zeros();",
      "            if idx == 0 {",
      "                len = self.cap;",
      "            } else {",
      "                idx -= 1;",
      "            }",
      "            let mut val = M::id();",
      "            let mut val_next = M::op(&self.values[idx], &val);",
      "            while f(&val_next) {",
      "                val = val_next;",
      "                a -= len;",
      "                if idx == 0 || (idx + 1).is_power_of_two() {",
      "                    return Some(0);",
      "                }",
      "                len <<= (!idx).trailing_zeros();",
      "                idx >>= (!idx).trailing_zeros();",
      "                idx -= 1;",
      "                val_next = M::op(&self.values[idx], &val);",
      "            }",
      "            idx = 2 * idx + 2;",
      "            len >>= 1;",
      "            while idx < self.values.len() {",
      "                val_next = M::op(&self.values[idx], &val);",
      "                if f(&val_next) {",
      "                    val = val_next;",
      "                    a -= len;",
      "                    idx -= 1;",
      "                }",
      "                len >>= 1;",
      "                idx = 2 * idx + 2;",
      "            }",
      "            Some(a)",
      "        }",
      "    }",
      "}",
      "macro_rules! define_monoid {",
      "    (\\$ name : ident , \\$ t : ty , \\$ id : expr , \\$ op : expr ) => {",
      "        #[derive(Clone, Copy, Debug)]",
      "        struct \\$name(\\$t);",
      "        impl Monoid for \\$name {",
      "            fn id() -> Self {",
      "                Self(\\$id)",
      "            }",
      "            fn op(&self, rhs: &Self) -> Self {",
      "                Self((\\$op)(self.0, rhs.0))",
      "            }",
      "        }",
      "        impl From<\\$t> for \\$name {",
      "            fn from(x: \\$t) -> \\$name {",
      "                Self(x)",
      "            }",
      "        }",
      "    };",
      "}"
    ]
  },
  "stringutil": {
    "prefix": "stringutil",
    "body": [
      "trait ToString {",
      "    fn to_string(self: Self) -> String;",
      "}",
      "impl<I, T> ToString for I",
      "where",
      "    I: IntoIterator<Item = T>,",
      "    T: std::convert::TryInto<u32>,",
      "{",
      "    fn to_string(self: Self) -> String {",
      "        self.into_iter()",
      "            .map(|t| t.try_into().ok().unwrap())",
      "            .map(|t| std::convert::TryInto::<char>::try_into(t).ok().unwrap())",
      "            .collect()",
      "    }",
      "}"
    ]
  },
  "tree_dfs": {
    "prefix": "tree_dfs",
    "body": [
      "#[allow(dead_code)]",
      "fn dfs(g: &Graph, v: usize, p: usize) {",
      "    g.out_edges[v]",
      "        .iter()",
      "        .map(|e| e.to)",
      "        .filter(|&u| u != p)",
      "        .for_each(|u| dfs(g, u, v))",
      "}"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "#[derive(Clone, Copy, Debug)]",
      "enum UnionFindNode {",
      "    Root { size: usize },",
      "    Child { parent: usize },",
      "}",
      "struct UnionFind {",
      "    g: Vec<UnionFindNode>,",
      "}",
      "#[allow(dead_code)]",
      "impl UnionFind {",
      "    fn new(n: usize) -> UnionFind {",
      "        use UnionFindNode::*;",
      "        UnionFind {",
      "            g: (0..n).map(|_| Root { size: 1 }).collect(),",
      "        }",
      "    }",
      "    fn root(&mut self, v: usize) -> usize {",
      "        use UnionFindNode::*;",
      "        let p = match self.g[v] {",
      "            Root { size: _ } => return v,",
      "            Child { parent: p } => p,",
      "        };",
      "        let r = self.root(p);",
      "        self.g[v] = Child { parent: r };",
      "        r",
      "    }",
      "    fn unite(&mut self, v: usize, u: usize) -> bool {",
      "        use UnionFindNode::*;",
      "        let rv = self.root(v);",
      "        let ru = self.root(u);",
      "        if rv == ru {",
      "            return false;",
      "        }",
      "        let size_rv = self.size(rv);",
      "        let size_ru = self.size(ru);",
      "        let (rsmall, rlarge) = if size_rv < size_ru {",
      "            (rv, ru)",
      "        } else {",
      "            (ru, rv)",
      "        };",
      "        self.g[rsmall] = Child { parent: rlarge };",
      "        self.g[rlarge] = Root {",
      "            size: size_rv + size_ru,",
      "        };",
      "        true",
      "    }",
      "    fn same(&mut self, v: usize, u: usize) -> bool {",
      "        self.root(v) == self.root(u)",
      "    }",
      "    fn size(&mut self, v: usize) -> usize {",
      "        use UnionFindNode::*;",
      "        let rv = self.root(v);",
      "        match self.g[rv] {",
      "            Root { size } => size,",
      "            Child { parent: _ } => unreachable!(),",
      "        }",
      "    }",
      "}"
    ]
  }
}
