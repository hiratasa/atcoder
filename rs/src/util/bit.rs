// BIT
//  区間和と単一要素への加算が高速にできる
//  一般的には可換モノイドならOK
//  (sum_betweenを使うなら可逆性も要求⇒群になる)

trait Monoid {
    type Item: Clone;

    fn id() -> Self::Item;
    fn op(lhs: &Self::Item, rhs: &Self::Item) -> Self::Item;
}

//  1-indexedで、
//    iの最後に立っているビットをB（=i&-i)として、
//    values_iは [i - (i&-i) + 1, i] の区間の和を保持
//    (といいつつ0-indexにアクセスする箇所で直してる)
// M must be commutative.
struct BIT<M>
where
    M: Monoid,
{
    len: usize,
    values: Vec<M::Item>,
}

#[allow(dead_code)]
impl<M> BIT<M>
where
    M: Monoid,
{
    fn new(len: usize) -> BIT<M> {
        BIT {
            len,
            values: vec![M::id(); len],
        }
    }

    fn with(vals: &Vec<M::Item>) -> Self {
        let mut bit = Self::new(vals.len());

        for (i, v) in vals.iter().enumerate() {
            bit.add(i, v.clone());
        }

        bit
    }

    // [0, i)の和
    fn sum(&self, i: usize) -> M::Item {
        let mut s = M::id();
        let mut idx = i as i64;

        // values[1] ~ values[i] の和
        // (bは1-indexedなのでこれでOK)
        while idx > 0 {
            s = M::op(&s, &self.values[(idx - 1) as usize]);
            idx -= idx & -idx;
        }

        return s;
    }

    fn add(&mut self, i: usize, a: M::Item) {
        // 1-indexedに直す
        let mut idx = i as i64 + 1;

        while idx as usize <= self.len {
            self.values[(idx - 1) as usize] = M::op(&self.values[(idx - 1) as usize], &a);
            idx += idx & -idx;
        }
    }

    fn len(&self) -> usize {
        self.len
    }
}

// 可換群
trait Group: Monoid {
    fn inv(value: &Self::Item) -> Self::Item;
}

#[allow(dead_code)]
impl<M> BIT<M>
where
    M: Group,
{
    // [i, j) の和
    fn sum_between(&self, i: usize, j: usize) -> M::Item {
        M::op(&self.sum(j), &M::inv(&self.sum(i)))
    }
}

macro_rules! define_monoid {
    ($name: ident, $t: ty, $id: expr, $op: expr) => {
        struct $name;

        impl Monoid for $name {
            type Item = $t;

            fn id() -> Self::Item {
                $id
            }

            fn op(lhs: &Self::Item, rhs: &Self::Item) -> Self::Item {
                ($op)(*lhs, *rhs)
            }
        }
    };
}

macro_rules! define_group {
    ($name: ident, $t: ty, $id: expr, $op: expr, $inv: expr) => {
        define_monoid!($name, $t, $id, $op);

        impl Group for $name {
            fn inv(value: &Self::Item) -> Self::Item {
                ($inv)(*value)
            }
        }
    };
}

define_group!(Sum, i64, 0, std::ops::Add::add, std::ops::Neg::neg);

mod test {
    #[allow(unused_imports)]
    use super::*;

    #[test]
    fn test_bit() {
        let mut bit: BIT<Sum> = BIT::new(5);

        bit.add(0, 1);
        bit.add(1, 2);
        bit.add(2, 3);
        bit.add(3, 4);
        bit.add(4, 5);

        assert_eq!(0, bit.sum(0));
        assert_eq!(1, bit.sum(1));
        assert_eq!(3, bit.sum(2));
        assert_eq!(6, bit.sum(3));
        assert_eq!(10, bit.sum(4));
        assert_eq!(15, bit.sum(5));

        assert_eq!(9, bit.sum_between(1, 4));
    }
}
